\documentclass{beamer}
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[english, russian]{babel} % Языки: русский, английский
\usepackage{textcase}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{MnSymbol}
\usepackage{listings}
\usepackage{hyperref}
\usetheme{Warsaw}
\usecolortheme{beaver}

\title[XS-схемы] % (optional, only for long titles)
{XS-схемы построения тактовых подстановок блочных криптосистем: характеристики перемешивания}
\author[Миронович С.] % (optional, for multiple authors)
{Миронович Светлана\\ 5 курс 9 группа, кафедра ММАД\\~ \\Руководитель: Агиевич Сергей Валерьевич \\ Заведующий НИЛ ПБИТ\\ кандидат физико-математических наук}
\institute[БГУ] % (optional)
{
  Белорусский государственный университет\\
  Факультет прикладной математики и информатики
}
\date[2017] % (optional)
{Минск, 2017}
\subject{Computer Science}

\begin{document}
\frame{\titlepage}

  \begin{frame}
    \frametitle{$XS$ схемы}
В $XS$-схемах возможны только 2 операции:
\begin{itemize}
\item Операция исключающее ИЛИ
\item Подстановка в S-блок
\end{itemize}
$XS_1$-схемы - это схемы, где используется только один $S$-блок.
Все $XS_1$-схемы можно задать тройкой $(a, B, c)$ или расширенной матрицей:
$$
\begin{pmatrix}
b_{11} & b_{12} & \ldots & b_{1n} & a_1\\
b_{21} & b_{22} & \ldots & b_{2n} & a_2\\
\dotfill\\
b_{n1} & b_{n2} & \ldots & b_{nn} & a_n\\
c_1    & c_2    & \ldots & c_n    & 0\\
\end{pmatrix}.
$$
Тогда преобразование выглядит следующим образом:
$$y = xB + S(xa)c, x = (X_1, X_2, X_3, ..., X_n)$$.
  \end{frame}
 \begin{frame}
    \frametitle{$XS$ схемы}
Например, рассмотрим тактовую подстановку Skipjack A. Она задается следующим преобразованием:
$$X_1, X_2, X_3, X_4 \rightarrow X_4+S(X_1), S(X_1), X_2, X_3$$
А тогда ее расширенная матрица выглядит следующим образом:
$$
\begin{pmatrix}
0 & 0 & 0 & 0 & 1\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0\\
1 & 0 & 0 & 0 & 0\\
1    & 1    & 0 & 0    & 0\\
\end{pmatrix}.
$$
  \end{frame}

 \begin{frame}
    \frametitle{Подходы к изучению характеристик перемешивания на XS схемах}

Рассматривалось два принципиально разных подхода к исследованию характеристик перемешивания на XS схемах:
\begin{itemize}
\item Граф и матрица зависимости

Граф зависимости - это граф, чьи вешины - это номера битов. Из $i$ есть ребро в $j$, если $i$-тый входной бит влияет на $j$-тый выходной (а вес ребра характеризует степень влияния).
\item Графы линейных и разностных переходов

Графы линейных и разностных переходов неявно описывают подверженность тактовой подстановки линейной и дифференциальной атакам.
\end{itemize}
  \end{frame}

 \begin{frame}
    \frametitle{Граф и матрица зависимости}

Все преобразование зашифрования представим в виде подстановки $\sigma$.
Подстановке $\sigma$, действующей на $\{0,1\}^n$, 
поставим в соответствие {\it матрицу зависимостей}~$A_\sigma=(a_{ij})$.
Элемент $a_{ij}$ этой матрицы характеризует влияние $i$-го
бита прообраза~$\sigma$ на $j$-й бит образа.

Степень влияния можно описывать по-разному.
Рассмотрим два варианта:
\begin{enumerate}
\item
{\it Индикаторы}: $a_{ij}=1$,
если изменение $i$-го бита $X$ может привести 
к изменению $j$-го бита $\sigma(X)$,
и $a_{ij}=0$ в противном случае.

\item
{\it Вероятности}: 
$$
a_{ij}=\Pr\big\{\sigma(X)_j\neq \sigma(X\oplus 2^i)_j\colon
X\stackrel{R}\leftarrow\{0,1\}^n\big\}.
$$
\end{enumerate}
  \end{frame}


 \begin{frame}
    \frametitle{Построение матрицы зависимости}
Если $\sigma$ является композицией $\sigma_d\ldots\sigma_2\sigma_1$,
то
$$
A_\sigma=A_{\sigma_1}A_{\sigma_2}\ldots A_{\sigma_d}.
$$
Для тождественной подстановки $id$ матрица $A_{id}$
является единичной: $A_{id}=I_n$.

Если слово~$X$ разбито на части~$X_1,X_2,\ldots,X_d$ 
и~$\sigma(X)=\sigma_1(X_1)\parallel\sigma_2(X_2)\parallel\ldots\sigma_d(X_d)$,
то
$$
A_\sigma=
\begin{pmatrix}
A_{\sigma_1} & 0 & \ldots & 0\\
0 & A_{\sigma_2} & \ldots & 0\\
0 &   0          & \ldots & A_{\sigma_d}\\
\end{pmatrix}.
$$
  \end{frame}

 \begin{frame}
    \frametitle{Элементарные преобразования}
\textbf{Перестановка битов. } По перестановке построим перестановочную матрицу. Например, пусть дана перестановка $P = (3~1~2)$. Тогда матрица $A_p$ примет вид:

$$
A_p = 
\begin{pmatrix} 
0 & 1 & 0\\ 
0 & 0 & 1\\ 
1 & 0 & 0\\
\end{pmatrix}.
$$

\textbf{Сложение $\oplus$.} Пусть $n$~--- четное, $m=n/2$,
$X=X_1\parallel X_2$, 
и $\oplus(X)=(X_1\oplus X_2)\parallel X_2$.
Тогда и в индикаторном, и в вероятностном описании 
матрица зависимостей имеет вид:
$$
A_\oplus = 
\begin{pmatrix} 
I_m & 0\\ 
I_m & I_m 
\end{pmatrix}.
$$
  \end{frame}

{\bf Сложение $\boxplus$}.
Сохраняя соглашения предыдущей операции,
пусть $\boxplus(X)=(X_1\boxplus X_2)\parallel X_2$.
Тогда индикаторная матрица зависимостей:
$$
A_\boxplus = 
\begin{pmatrix} 
U_m & 0\\ 
U_m & I_m 
\end{pmatrix}.
$$
Здесь~$U_m$~--- матрица с единицами на и выше главной диагонали,
и нулями ниже главной диагонали. 
Например, $U_4$ имеет вид:

$$
U_m = 
\begin{pmatrix} 
1 & 1 & 1 & 1\\ 
0 & 1 & 1 & 1\\ 
0 & 0 & 1 & 1\\
0 & 0 & 0 & 1\\
\end{pmatrix}.
$$

В вероятностной матрице зависимостей матрица 
$U_m$ меняется на матрицу $P_m$ из элементов 
$$
p_{ij}=\begin{cases}
2^{i-j}, & j\geq i,\\
0,       & j< i.
\end{cases}
$$

{\bf Подстановка на $S$-блоках}.
Пусть $n=mr$, $S_1,S_2,\ldots,S_r$~---
криптографически надежные $S$-блоки,
действующие на слова длины~$m$ и 
пусть 
$$S(X)=S(X_1\parallel X_2\parallel\ldots\parallel X_r)=$$
$$=S_1(X_1)\parallel S_2(X_2)\parallel\ldots\parallel S_r(X_r),\quad
X_i\in\{0,1\}^m.
$$

Индикаторная матрица зависимостей:
$$
A_S = 
\begin{pmatrix} 
J_m & 0 & \ldots & 0\\ 
0 & J_m & \ldots & 0\\
  &     & \ldots &\\
0 &  0  & \ldots & J_m\\
\end{pmatrix}.
$$
Здесь~$J_m$~--- матрица порядка $m$ из всех единиц.


\begin{frame}
    \frametitle{Характеристики на матрице зависимости}

Посчитаем на матрице зависимости собственные значения и упорядочим их по убыванию модуля, т.е. найдем такие собстенные значения $\lambda_1, \lambda_2, ..., \lambda_n$, что $|\lambda_1| \ge |\lambda_2| \ge ... \ge |\lambda_n|$.

 Можно ввести три следующие характеристики перемешивания на матрице зависимости:

\begin{itemize}
\item Экспонент, $exp(G)$

Это степень, в которую нужно возвести матрицу зависимости, чтобы в ней не осталось нулей
\item $\lambda(G)$

Максимальное по модулю собственное значение, т.е. $\lambda_1$.
\item $k(G)$

$k(G) = \frac{\lambda_2}{\lambda_1}$
\end{itemize}

  \end{frame}

\begin{frame}
    \frametitle{Вычисления характеристик на криптосистеме belt}

Были вычислены характеристики $k(G), \lambda(G), exp(G)$ для вероятностной и индикаторной матрицы зависимости криптосистемы $belt$. Результаты следующие.

Индикаторная матрица зависимости:

$$k(G) = 0.13326654881663205$$
$$\lambda(G) = 109.7691521877077$$
$$exp(G) = 2$$

Вероятностная матрица зависимости:

$$k(G) = 0.3914373414043516$$
$$\lambda(G) = 1027.8610668901583$$
$$exp(G) = 2$$
  \end{frame}


\begin{frame}
    \frametitle{XS схемы и экспонент}
Удалось доказать следующую теорему.

\textbf{Теорема:} Экспонент матрицы зависимости любой тактовой подстановки из класса XS не зависит от длины блока $n$ для $n \ge 2$.

  \end{frame}

  \begin{frame}
    \frametitle{Граф разностных переходов}
Пусть у нас есть $X=X_1||X_2||...||X_n$ и $X'=X_1'||X_2'||X_3'||...||X_n'$, которые после одного такта переходят в $Y=Y_1||Y_2||Y_3||...||Y_n$ и $Y'=Y_1'||Y_2'||Y_3'||...||Y_n'$. Вектора $u$ и $v$ будем называть разностными индикаторами для $X, X'$ и $Y, Y'$ соответственно, если:
$$
u_i=I\left\{X_i\ne X'_i\right\}=\left\{ \begin{array}{c}
1,X_i\ne X'_i \\
0,X_i=X'_i \end{array}
\right.i=1,\dots , n.
$$
$$
v_i=I\left\{Y_i\ne Y'_i\right\}=\left\{ \begin{array}{c}
1,Y_i\ne Y'_i \\
0,Y_i=Y'_i \end{array}
\right.i=1,\dots , n.
$$
Тогда говорят, что из $u$ существует разностный переход в $v$.
Также будем говорить, что $S$-блок разностно активен, если от $X$ и $X'$ в $S$-блок поступают разные вектора (или, что то же самое, когда $(a,u) > 0$).
Тогда графом разностных переходов называется граф, вершины которого - это вектора $\{0, 1\}^n$, а ребро из $u$ в $v$ существует тогда и только тогда, когда существует разностный переход из $u$ в $v$. Причем вес ребра будет 1, если $S$-блок разностно активен; иначе 0.

  \end{frame}
\begin{frame}
    \frametitle{Граф линейных переходов}
На вход тактовой подстановке поступает $X = X_1||X_2||...||X_n$, на выходе получаем $Y=E(X) = Y_1||Y_2||...||Y_n$.
Индикатором $q = (q_1, q_2, ..., q_n)$ для $a=(a_1, a_2, ..., a_n)$ назовем:
$$q_i=I\left\{a_i\ne 0\right\}=\left\{ \begin{array}{c}
1,a_i \neq 0 \\
0,a_i = 0\end{array}
\right.i=1,\dots , n.$$
Если следующее соотношение выполняется для всех $X_i, i=\overline{1,n}$:
$$\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = \beta_1Y_1 + \beta_2Y_2 + ... + \beta_nY_n$$
Или, записывая иначе:
$$\gamma_1X_1 + \gamma_2X_2 + ... + \gamma_nX_n = \gamma S(a_1X_1 + a_2X_2 + ... + a_nX_n)$$
причем $q$ идентификатор для $\alpha$, $r$ идентификатор для $\beta$, тогда говорят, что из $q$ совершен линейный переход в $r$. И тогда $S$-блок будет называться линейно активным, если $\gamma \neq 0$.
  \end{frame}
\begin{frame}
    \frametitle{Граф линейных переходов}
Графом линейных переходов будем называть такой ориентированный весовой граф, у которого вершинами являются вектора $\{0, 1\}^n$, и из вершины $q$ есть ребро в вершину $r$ тогда и только тогда, когда существуют такие $\alpha = (\alpha_1, \alpha_2, ..., \alpha_n)$, $\beta = (\beta_1, \beta_2, ..., \beta_n)$, что для любых $X_1, X_2, ..., X_n$ выполняется $\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = \beta_1Y_1 + \beta_2Y_2 + ... + \beta_nY_n$, и притом $q, r$ являются соответственно индикаторами для $\alpha, \beta$. Ребро из $q$ в $r$ имеет вес 1, если $S$-блок является в данном соотношении линейно активным; иначе вес ребра равен 0.
  \end{frame}
\begin{frame}
    \frametitle{Легчайший путь длины $k$ в графе}
\begin{algorithm}[H]
\caption{Модифицированный Алгоритм Беллмана-Форда}
\label{diff_graph_construct}
\textbf{Вход:} Граф $G$.\\
\textbf{Выход:} Массив $\pi_l$, в котором $\pi_l[v]$ содержит самый легкий путь длины $l$ до вершины $v$.\\
Шаг 0. Создаем массив $\pi_0$ длины $n$ и заполняем его $0$. \\
Шаг 1. Для $k$ от 1 до $l$ делаем следующее:\\
Шаг 1.1 Создаем массив $\pi_k$ и заполняем его $+\infty$,\\
Шаг 1.2 Для всех ребер $(u, v) \in E:$\\
Шаг 2.1.1 Если $\pi_k[v] > \pi_{k-1}[u] + w(u,v)$, то $\pi_k[v] = \pi_{k-1}[u] + w(u,v)$\\
Шаг 3. Возвращаем $\pi_l$.\\
\end{algorithm}
  \end{frame}
\begin{frame}
    \frametitle{Цикл минимального среднего веса}
\begin{algorithm}[H]
\caption{Алгоритм нахождения $\Lambda$}
\label{diff_graph_construct}
\textbf{Вход:} Граф $G$\\
\textbf{Выход:} $\Lambda$.\\
Шаг 0. Вычислим все вектора $\Pi_i$ для $i = \overline{1, ITER}$. Также в процессе подсчета $\Pi_i$ создадим вектора $prev_i$, где $prev_i[v]$ хранит значение, из какой вершины был совершен последний переход в вершину $v$ по легчайшему пути длины $i$.\\
Шаг 1. Присваиваем $minMean = \infty$.\\
Шаг 2. Для каждой вершины $v \in V$, для которой справедливо $\Pi_{ITER}[v] \ne \infty$, делаем следующее:\\
Шаг 2.1. Восстанавливаем последний цикл, который содержится в легчайшем пути длины $ITER$, ведущим в $v$. Это вычисляется следующим образом:\\
Шаг 2.2. Создаем пустой вектор и пустое хэш-множество $visitedVerticesArray$ и $visitedVerticesSet$.\\
\end{algorithm}
  \end{frame}
\begin{algorithm}[H]
\caption{Алгоритм нахождения $\Lambda$ (продолжение)}
Шаг 2.3. Записываем $currentVertice = v; iteration = ITER$.\\
Шаг 2.3. Пока $currentVertice \notin visitedVerticesSet$:\\
Шаг 2.3.1. Добавляем $currentVertice$ в $visitedVerticesSet$.\\
Шаг 2.3.2. Добавляем последним $currentVertice$ в $visitedVerticesArray$.\\
Шаг 2.3.3. $currentVector = prev_{iteration}[currentVector]$.\\
Шаг 2.3.4. $iteration--$.\\
Шаг 2.4. Цикл найден, восстанавливаем цикл по $visitedVerticesArray$ простым проходом от предпоследнего элемента к началу со сравнением элемента вектора с последним элементом вектора.\\
Шаг 2.5. Если $minMean$ больше среднего веса найденного цикла, то записываем в $minMean$ значение среднего веса этого цикла.\\
Шаг 3. Возвращаем $minMean$.\\ 
\end{algorithm}
\begin{frame}
    \frametitle{Результаты вычисления mcm на графах линейных и разностных переходов}

\begin{tabular}{ l | c | c }
  \hline			
  Схема & mcm на графе & mcm на графе \\
   & разностных переходов & линейных переходов \\
\hline
  Feistel & 0.(6) & 0.(6) \\
  Skipjack A & 0.5(3) & 0.5(3) \\
  Skipjack B & 0.5(3) & 0.5(3) \\
  SMS4 & 0.(857142) & 0.4 \\
  Lai-Massey & 1& 1 \\
  Matsui-L & 0.5 & 0.5 \\
  Matsui-R & 0.(6) & 0.(6) \\
  GFN-1 & 0.5(3) & 0.5(3) \\
  GFN-1-Inv & 0.5(3) & 0.5(3)  \\
  MARS-3 & 0.4 & 0 \\
  \hline  
\end{tabular}

  \end{frame}

\begin{frame}
    \frametitle{Вычисление mcm на belt keywrap}

\begin{tabular}{ l | c | c }
  \hline			
  Длина блока & mcm на графе & mcm на графе \\
   & разностных переходов & линейных переходов \\
\hline
  2 & 0.(6) & 0.(6) \\
  3  & 0.75 & 0.5 \\
  4  & 0.8 & 0.(3) \\
  5 & 0.8(3) & 0.25 \\
  6 & 0.(857142) & 0.2 \\
  7 & 0.875 & 0.1(6) \\
  8 & 0.(8) & 0.(142857) \\
  9 & 0.9 & 0.125 \\
  10 & 0.(90) & 0.(1)  \\
  11 & 0.91(6) & 0.1 \\
  \hline  
\end{tabular}
Здесь прослеживается зависимость с длиной блока. Так, mcm для графа разностных переходов описывается формулой $\frac{n}{n+1},$ где $n$ - длина блока. Также mcm для графа линейных переходов может быть описан формулой $\frac{1}{n-1},$ где $n$ также длина блока.

  \end{frame}

\begin{frame}
\begin{center} \textbf{Спасибо за внимание!} \end{center}
\end{frame}
% etc
\end{document}