\documentclass[a4paper,12pt]{extarticle}
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[english, russian]{babel} % Языки: русский, английский
\usepackage{textcase}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[amsmath,thmmarks]{ntheorem}
\usepackage{MnSymbol}
\usepackage{listings}
\geometry{a4paper,top=2cm,bottom=2cm,left=3cm,right=1cm}
\theoremstyle{plain} % default
\newtheorem{theorem}{Теорема}
\newtheorem{proof}{Доказательство}
\begin{document}
\thispagestyle{empty}
\vspace*{2cm}

\thispagestyle{empty}
\begin{normalsize}
\begin{center}
{\bf МИНИСТЕРСТВО ОБРАЗОВАНИЯ РЕСПУБЛИКИ БЕЛАРУСЬ}
\end{center}

\begin{center}
{\bf БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ}
\end{center}

\begin{center}
{\bf Факультет прикладной математики и информатики}
\end{center}

\begin{center}
Кафедра математического моделирования и анализа данных
\end{center}
\end{normalsize}
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\begin{center}
{\bf МИРОНОВИЧ СВЕТЛАНА ЮРЬЕВНА}
\end{center}
\bigskip

\begin{center}
{\bf XS-схемы построения тактовых подстановок блочных криптосистем: характеристики перемешивания}
\end{center}
\bigskip
\bigskip
\bigskip
\bigskip

\begin{center}
Отчет по преддипломной практике\linebreak
студентки 5 курса 9 группы
\end{center}
\bigskip
\bigskip
\bigskip
\bigskip
%\begin{flushleft}
\linespread{1.0}
\begin{tabular}{@{}p{12cm}@{}p{5cm}}
{\small ''Допустить к защите''} & {\bf\small Научный руководитель}\\
{\small{}} & {\small Агиевич Сергей Валерьевич }\\
\begin{picture}(280,15)\put(140, 0){\line(1,0){140}}\end{picture}& {\small заведующий НИЛ ПБИТ} \\
\begin{picture}(140,15)\put(0,0){1 \quad\put(0,0){ марта {\small~ 2017 г}}}\end{picture} 
{}&{\small кандидат физ.-мат. наук}\\
\end{tabular}
%\end{flushleft}

\vspace{\stretch{1}}

\begin{center}
\bf{МИНСК 2017}
\end{center}
\begin{large}
\newpage
\tableofcontents
 
\clearpage

\newpage
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\vspace*{1cm}

Современный мир невозможно представить без криптографии [1]. Телефонные звонки, сообщения в социальных сетях, интернет-банкинг - все это требует специальные средства для защиты данных каждого пользователя. Как никогда остро стоит вопрос целостности (т.е. уверенность, что данные не были изменены) и конфиденциальности (т.е. необходимость предотвращения утечки или разглашения) информации [2]. Таким образом, знание о том, как сравнивать криптосистемы и находить наилучшую криптосистему из множества является прикладным.

С другой стороны, важной проблемой является быстродействие. Некоторые приложения в интернете, такие как видеозвоки, должны не только защищать целостность и конфиденциальность, но еще и работать "на лету". В данном случае важным параметром становится количество операций, необходимое для одного такта зашифрования.

Таким образом, для ряда задач требуются криптосистемы, которые для своего количества операций являются наиболее криптостойкими по некоторой заданной метрике.

На текущий момент в криптографии есть два вида криптосистем: симметричные, которые в преобразованиях зашифрования и расшифрования используют один и тот же ключ, и асимметричные, которым для зашифрования и расшифрования требуются разные ключи [3]. Симметричные криптосистемы в свою очередь разделяются на блочные (когда исходный текст разбивается на блоки одинаковой длины и преобразование зашифрования применяется к каждому блоку поотдельности) и поточные (когда генерируется гамма-последовательность и шифртекст получается как результат применения операции XOR над исходным текстом и гамма-последовательностью)[4]. 

Тактовую подстановку блочной криптосистемы можно задать схемой~---
ориентированным графом, который описывает ход вычислений. Дальше мы будем говорить о криптосистемах как о схемах и рассматривать свойства именно схем.

Блочные криптосистемы можно классифицировать по операциям, которые применяются в тактовых подстановках на каждом фрагменте. Используют следующие операции:

\begin{itemize}
\item R
\newline Операция циклического сдвига
\item L
\newline Логические операции И и ИЛИ
\item S
\newline Замена на S-блоке
\item X
\newline Применение операции XOR над двумя фрагментами
\item A
\newline Сложение фрагментов длины m как чисел по модулю $2^m$
\end{itemize}

Различные сочетания этих операций дают различные типы схем. Так, криптосистемы SM4 и Skipjack принадлежат к классу XS, AES можно отнести к классу XLS, а схемы криптосистем Salsa20, ChaCha и CAST-128 относятся к классу ARX[5].

Целью данной работы является исследование так называемых XS схем с целью нахождения оптимальной с точки зрения как криптостойкости, так и быстродействия схемы.


\newpage
\section*{1 Построение схем $XS$}
\addcontentsline{toc}{section}{1 Построение схем $XS$}
\vspace*{1cm}

Пусть на вход поступает двоичное слово $X$, из которого в ходе зашифрования получают $Y$. Тактовые подстановки функционируют следующим образом: $X$ разбивается на $n$ равных по длине частей $X_1, X_2, X_3, ..., X_n \in \{0, 1\}^m, X = X_1||X_2||X_3||...||X_n$. Фрагменты $X_i$ интерпретируются как вектора длины $m$ над полем $\{0, 1\}$. Затем вычисляется $Y_i, i = \overline{1,n}$ как комбинация фрагментов $X_j$ с некоторыми операциями, такими как битовый сдвиг, исключающее ИЛИ, сумма по модулю $2^m$, замена на S блоке, логическое И, логическо ИЛИ и т.д. Затем фрагменты $Y_i$ объединяются, чтобы получить выходное значение $Y: Y = Y_1||Y_2||Y_3||...||Y_n$. Здесь $n$ называют размерностью схемы, количество битов в $X_i, Y_i$ $m$ - размером фрагмента.

Рассмотрим схемы, в которых есть только операции замены на S-блоке и исключающее ИЛИ. Обозначим такие схемы как $XS$, подразумевая, что $X$ в названии $XS$ означает исключающее ИЛИ, $S$ означает замену на $S$ блоке. 

Все $XS$ схемы можно разделить на классы в зависимости от того, сколько различных $S$ блоков используется внутри схемы. Так, $XS_k$ обозначает такую $XS$-схему, в которой присутствует $k$ различных $S$ блоков. Таким образом, будет справедливо следующее: $XS = XS_1 \cup XS_2 \cup ... \cup XS_k \cup...$. Можно также провести аналогичное разделение по количеству операций исключающего ИЛИ, необходимых для одного такта, т.е. $X_lS_k$ - схема с $l$ сложениями по модулю 2 и $k$ заменами на $S$ блоке. Понятно, что значения $l, k$ характеризуют сложность схемы: чем они больше, тем схема сложнее.

Основным объектом изучения будут схемы с одним блоком $S$ и неограниченным количеством операций XOR, т.е. схемы $XS_1$. К схемам $XS_1$ можно отнести ряд тактовых подстановок, таких как Skipjack A, Skipjack B, SM4. 

Схемы $XS$ размерности $n$ можно задать в виде матрицы $B = (b_{ij})$ размерности $n \times n$, вектора-строки $c = (c_i)$ размерности $n$ и вектора-столбца $a=(a_i)$ размерности $n$ следующим образом:

$$u = a_1X_1 + a_2X_2 + ... + a_nX_n$$
$$v = S(u)$$
$$Y_i = b_{1i}X_1 + b_{2i}X_2 + ... + b_{ni}X_n + c_iv, \forall i = \overline{1,n}$$

Здесь "+" обозначает операцию сложения по модулю 2, а $b_{ij}, a_i, c_i \in \{0, 1\}$, и соответственно, если $b_{ij} = 0 \vee c_j=0 \vee a_j = 0$, мы полагаем, что соответствющий вектор $X_j$ не участвует в сложении по модулю 2. В случае же, когда $b_{ij} = 1 \vee c_j=1 \vee a_j = 1$, соответствующий вектор $X_j$ включается в сложение.

Соответственно, преобразование можно задать в матричной форме:

$$y = xB + S(xa)c, x = (X_1, X_2, X_3, ..., X_n)$$.

В таком случае, видно, что вся схема $XS_1$ однозначно задается тройкой $(a, B, c)$. 

Также удобно записывать $(a, B, c)$ в виде следующей матрицы, которую будем называть расширенной:

$$
\begin{pmatrix}
b_{11} & b_{12} & \ldots & b_{1n} & a_1\\
b_{21} & b_{22} & \ldots & b_{2n} & a_2\\
\dotfill\\
b_{n1} & b_{n2} & \ldots & b_{nn} & a_n\\
c_1    & c_2    & \ldots & c_n    & 0\\
\end{pmatrix}.
$$

Рассмотрим на примере тактовой подстановки Skipjack A:

$$u = X_1$$
$$v = S(u)$$
$$Y_1 = X_4 + v$$
$$Y_2 = v$$
$$Y_3 = X_2$$
$$Y_4 = X_3$$

Или в виде расширенной матрицы:

$$
\begin{pmatrix}
0 & 0 & 0 & 0 & 1\\
0 & 0 & 1 & 0 & 0\\
0 & 0 & 0 & 1 & 0\\
1 & 0 & 0 & 0 & 0\\
1    & 1    & 0 & 0    & 0\\
\end{pmatrix}.
$$

В ходе преддипломной практики был разработан и реализован программно формат представления схем класса $XS_1$. Код, выполняющий чтение из файла матричного представления схемы и создающий объект схемы $XS_1$ можно найти в приложении. 

\newpage
\section*{2 Граф разностных переходов}
\addcontentsline{toc}{section}{2 Граф разностных переходов}
\vspace*{1cm}

Пусть у нас есть схема $XS_1$ с параметрами $(a, B, c)$. Обозначим ее как $E$,  $E(X)$ - результат подстановки $X$ в схему $E$. 

Пусть также на вход схемы поступает два различных входа $X=X_1||X_2||...||X_n$ и $X'=X_1'||X_2'||X_3'||...||X_n'$, которые соответственно после проведения одного такта схемы преобразуются в $Y=Y_1||Y_2||Y_3||...||Y_n$ и $Y'=Y_1'||Y_2'||Y_3'||...||Y_n'$. Введем два вектора, $u$ и $v$ такие, что:

$$
u_i=I\left\{X_i\ne X'_i\right\}=\left\{ \begin{array}{c}
1,X_i\ne X'_i \\
0,X_i=X'_i \end{array}
\right.i=1,\dots , n.
$$
$$
v_i=I\left\{Y_i\ne Y'_i\right\}=\left\{ \begin{array}{c}
1,Y_i\ne Y'_i \\
0,Y_i=Y'_i \end{array}
\right.i=1,\dots , n.
$$

Будем называть $u$ разностным индикатором для $X$ и $X'$, и соответственно $v$ - это разностный индикатор $Y$ и $Y'$.

Говорят, из $u$ совершен разностный переход в $v$, когда существует два таких вектора $X$ и $X'$ такие, что $u$ - это их разностный индикатор, а $v$ является разностным индикаторов векторов $E(X) = Y, E(X') = Y'$.

$S$-блок при разностном переходе называется активным, если векторное произведение $(a, u) \neq 0$ (или, что то же самое, если $Xa \neq X'a$), поскольку в таком случае на вход $S$-блоку поступали разные вектора.

Тогда графом разностных переходов будем называть следующий ориентированный весовой граф. Его вершинами являются всевозможные битовые вектора длины $n$, и из вершины $u$ проведено ребро в вершину $v$ тогда и только тогда, когда из $u$ можно совершить разностный переход в $v$. Вес у этого ребра будет 1, если $S$-блок при таком разностном переходе является активным; в противном случае вес ребра будет 0.

Рассмотрим более подробно построоение графа разностных переходов на примере Skipjack A. Тактовая подстановка в Skipjack A выглядит, как упоминалось выше, следующим образом:

$$X_1, X_2, X_3, X_4 \rightarrow X_4 + S(X_1), S(X_1), X_2, X_3$$

Найдем, какие разностные переходы возможны из 1000.

Разностный индикатор 1000 для входных значений означает, что если нам на вход поступили вектора $X=X_1||X_2||X_3||X_4, X'=X_1'||X_2'||X_3'||X_4'$, то для них справедливо следующее: $X_1\neq X_1', X_2=X_2', X_3 = X_3', X_4 = X_4'$. 

Заметим, что поскольку $S$ биективна, то из $A \neq B$ следует $S(A) \neq S(B)$.

Но в таком случае видно, что $Y_1=X_4 + S(X_1)=X_4' + S(X_1)\neq X_4' + S(X_1')=Y_1', Y_2=S(X_1)\neq S(X_1')=Y_2', Y_3=X_2=X_2'=Y_3', Y_4=X_3= X_3'=Y_4'$. Таким образом, разностный индикатор для $Y, Y'$ равен 1100. Более того, $S$-блок является активным.

Из этого следует, что в разностном графе существует ребро из 1000 в 1100 с весом 1, и аналогичным образом выстраиваются все ребра в графе разностных переходов.

Рассмотрим, как изменяются компоненты разностного индикатора при выполнении одного такта. Заметим, что поскольку мы имеем дело только с $XS_1$ схемами, нам достаточно рассмотреть, как влияют на разностный индикатор операторы исключающее ИЛИ и $S$-блок.


\textbf{$S$-блок}

Поскольку $S$-блок биективен, то из $A \neq B$ тогда и только тогда, когда $S(A) \neq S(B)$. Это равносильно тому, что заметить следующее: пусть $u$ - некоторый разностный индикатор. Тогда если применить $S$-блок ко всем фрагментов обоих исходных векторов, из которого получен данный разностный индикатор, и посчитать разностный индикатор результата (условно можем обозначить его $S(u)$), то снова получится вектор $u$, т.е. нули вектора $u$ перейдут в нули вектора $S(u)$, единицы перейдут в единицы. Или, что то же самое, $u=S(u)$.

\textbf{Исключающее ИЛИ}

 Как было доказано в [putnum], для исключающего ИЛИ на разностных индикаторах (введем для этой операции специальное обозначение $\odot$) справедливы следующие соотношения:

\begin{itemize}
\item $0 \odot 0 = 0$
\item $0 \odot 1 = 1$
\item $1 \odot 0= 1$
\item $1 \odot 1 = 0$ и 1. 
\end{itemize}

Например, применим данную операцию к следующим векторам: 01101 и 11001. Получим:

$$01101 \odot 11001 = 1~_{1}^010~_{1}^0 = \{10100, 11100, 10101, 11101\}$$.

Введем также для удобства следующую бинарную операцию: $(u, v)^{\odot} = u_1v_1 \odot u_2v_2 \odot ... \odot u_nv_n$.

Поскольку мы знаем, как влияют операции $S$-блока и исключающее ИЛИ на разностные индикаторы, то мы можем теперь записать алгоритм построения графа разностных переходов:

\begin{algorithm}[H]
\caption{Алгоритм построения графа разностных переходов}
\label{diff_graph_construct}
\textbf{Вход:} $XS_1$-схема $(a, B, c), n$ - размерность схемы.\\
\textbf{Выход:} Граф разностных переходов для схемы $(a, B, c)$.\\
Шаг 0. Создаем квадратную матрицу res размера $2^n$ и заполняем ее -1. \\
Шаг 1. Для каждого вектора $v, v \in \{0, 1\}^n$ выполняем следующее: \\
Шаг 2.1 Вычисляем вес ребер $w$, исходящих из вершины, соответствующей вектору $v$, следующим образом: $w = 0~ if (a,v) = 0 ~else ~1$.\\
Шаг 2.2 Находим все вершины, куда ведут исходящие из $v$следующим образом: $i$-такя координата вершины определяется как $(v, B_i)^{\odot} \odot c_iw$, где $B_i$ - это $i$-тый столбец $B$. \\
Шаг 2.3 Для всех найденных вершин $v'$, куда будут вести ребра из $v$, пишем $res[v][v'] = w$.
Шаг 3. Возвращаем $res$.\\
\end{algorithm}

Очевидно, что сложность алгоритма будет зависеть от входа $(a,B,c)$ и будет не превышать $2^{2n}$.

В ходе преддипломной практики был разработан формат представления графов и поддержан программно. Также был разработан и реализован алгоритм, конвертирующий $XS_1$ схему в граф разностных переходов. Соответствующий код можно найти в приложении к отчету. 

\newpage
\section*{3 Граф линейных переходов}
\addcontentsline{toc}{section}{3 Граф линейных переходов}

Пусть у нас есть схема $XS_1$ с параметрами $(a, B, c)$. Обозначим ее как $E$,  $E(X)$ - результат подстановки $X$ в схему $E$. 

Пусть также на вход тактовой подстановки поступает $X = X_1||X_2||...||X_n$, и $Y=E(X) = Y_1||Y_2||...||Y_n$.

Индикатором $q = (q_1, q_2, ..., q_n)$ для вектора $a=(a_1, a_2, ..., a_n)$ будем называть следующий вектор:

\begin{equation}
q_i=I\left\{a_i\ne 0\right\}=\left\{ \begin{array}{c}
1,a_i \neq 0 \\
0,a_i = 0\end{array}
\right.i=1,\dots , n.
\end{equation}

Рассмотрим следующее соотношение:

\begin{equation}
\label{eq:lin_proportion}
\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = \beta_1Y_1 + \beta_2Y_2 + ... + \beta_nY_n
\end{equation}

Это соотношение должно выполняться для всех $X_1, X_2, ..., X_n$.

Понятно, что поскольку $Y_i$ является линейной комбинацией из $X_1, X_2, ..., X_n$, $S(a_1X_1 + a_2X_2 + ... + a_nX_n)$, то тогда соотношение можно переписать следующим образом:

\begin{equation}\label{eq:in_gamma}
\gamma_1X_1 + \gamma_2X_2 + ... + \gamma_nX_n = \gamma S(a_1X_1 + a_2X_2 + ... + a_nX_n)\end{equation}

Обозначим $q=(q_1, q_2, ..., q_n)$ как идентификатор для $\alpha=(\alpha_1, \alpha_2, ..., \alpha_n)$, $r=(r_1, r_2, ..., r_n)$ идентификатор для $\beta = (\beta_1, \beta_2, ..., \beta_n)$. И тогда про $q$ и $r$ можно сказать следующее: из $q$ совершен разностный переход в $r$. 

$S$-блок будет называться линейно активным, если $\gamma \neq 0$.

Теперь мы можем ввести определение графа линейных переходов. Графом линейных переходов будем называть такой ориентированный весовой граф, у которого вершинами являются вектора $\{0, 1\}^n$, и из вершины $q$ есть ребро в вершину $r$ тогда и только тогда, когда существуют такие $\alpha = (\alpha_1, \alpha_2, ..., \alpha_n)$, $\beta = (\beta_1, \beta_2, ..., \beta_n)$, что для любых $X_1, X_2, ..., X_n$ выполняется $\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = \beta_1Y_1 + \beta_2Y_2 + ... + \beta_nY_n$, и притом $q, r$ являются соответственно индикаторами для $\alpha, \beta$. Это ребро из $q$ в $r$ имеет вес 1, если $S$-блок является в данном соотношении линейно активным; иначе вес ребра равен 0.

Как было доказано в [putnum], для соотношений выше справедливы следующие свойства:

 \begin{equation} \label{eq:lin_property1} 1) a_i = 0 \rightarrow \gamma_i = 0 \end{equation}
 \begin{equation} \label{eq:lin_property2} 2) a_i = a_j = 1 \rightarrow \gamma_i = \gamma_j  
 \end{equation}
\begin{equation} \label{eq:lin_property3} 3)(\ref{eq:in_gamma}) \Rightarrow \rho (Xa) = \gamma S(Xa) \end{equation}

Воспользуемся этими свойствами, чтобы найти всевозможные линейные соотношения. Для этого сначала распишем уравнение (\ref{eq:lin_proportion}) так, чтоб в нем не осталось $Y_1, Y_2, ..., Y_n$. Для этого сначала введем обозначения и запишем исходное соотношение:

$$v = S(a_1X_1 + a_2X_2 + ... + a_nX+n)$$
$$\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = \beta_1Y_1 + \beta_2Y_2 + ... + \beta_nY_n \Rightarrow$$
Теперь распишем каждый $Y_i$ через $X_1, X_2, ..., X_n$.
$$\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = \beta_1(b_{11}X_1 + b_{21}X_2 + ... + b_{n1}X_n + c_1v) +$$
$$ +  \beta_2(b_{12}X_1 + b_{22}X_2 + ... + b_{n2}X_n + c_2v) +$$
$$+~ ...~ +$$
$$+ \beta_n(b_{1n}X_1 + b_{2n}X_2 + ... + b_{nn}X_n + c_nv) \Rightarrow$$
Затем перегруппируем в правой части слагаемые так, чтобы можно было выделить слагаемые с $X_1$, с $X_2$, ..., с $X_n$:
$$\alpha_1X_1 + \alpha_2X_2 + ... + \alpha_nX_n = (\beta_1b_{11} + \beta_2b_{12} + ... + \beta_nb_{1n})X_1 + $$
$$+(\beta_1b_{21} + \beta_2b_{22} + ... + \beta_nb_{2n})X_2 + ... + (\beta_1b_{n1} + \beta_2b_{n2} + ... + \beta_nb_{nn})X_n+$$
$$+ (\beta_1c_1 + \beta_2c_2 + ... + \beta_nc_n)v$$
И перенесем все слагаемые с $X_1, X_2, ..., X_n$ в левую часть, оставив в правой только те слагаемые, в которых присутствует $v$:
$$ (\alpha_1 + \beta_1b_{11} + \beta_2b_{12} + ... + \beta_nb_{1n})X_1 + (\alpha_2 + \beta_1b_{21} + \beta_2b_{22} + ... + \beta_nb_{2n})X_2 + $$
$$+...+ (\alpha_n + \beta_1b_{n1} + \beta_2b_{n2} + ... + \beta_nb_{nn})X_n =  (\beta_1c_1 + \beta_2c_2 + ... + \beta_nc_n)v$$
Перейдем теперь от векторов $\alpha_i, \beta_i$ к их индикаторам $\alpha_i', \beta_i'$ (и соответственно, переходим от операции исключающее ИЛИ к операции $\odot$):
$$ (\alpha_1' \odot \beta_1'b_{11} \odot \beta_2'b_{12} \odot ... \odot \beta_n'b_{1n})X_1 \odot (\alpha_2' \odot \beta_1'b_{21} \odot \beta_2'b_{22} \odot ... \odot \beta_n'b_{2n})X_2 \odot $$
$$\odot...\odot (\alpha_n' \odot \beta_1'b_{n1} \odot \beta_2'b_{n2} \odot ... \odot \beta_n'b_{nn})X_n =  (\beta_1'c_1 \odot \beta_2'c_2 \odot ... \odot \beta_n'c_n)v = $$
\begin{equation}\label{eq:not_final_lin}=(\beta_1'c_1 \odot \beta_2'c_2 \odot ... \odot \beta_n'c_n)S(a_1X_1 \odot a_2X_2 \odot ... \odot a_nX_n)\end{equation}
И в таком случае видно, что для всех тех $i$, таких что $a_i = 0$, коэффициенты при $X_i$ должны зануляться, поскольку при $a_i = 0$ правая часть не зависит от $X_i$, и следовательно, от $X_i$ не должна зависеть и левая часть. Получаем следующее соотношение: 
$$\alpha_i' \odot \beta_1'b_{i1} \odot \beta_2'b_{i2} \odot ... \odot \beta_n'b_{in} = 0 ~ \forall i: ~a_i = 0$$
А для всех $i$ таких, что $a_i = 1$, ясно, что справедливо следующее:
$$\alpha_i' \odot \beta_1'b_{i1} \odot \beta_2'b_{i2} \odot ... \odot \beta_n'b_{in} = (\beta_1'c_1 \odot \beta_2'c_2 \odot ... \odot \beta_n'c_n) ~ \forall i: ~a_i = 1$$
И теперь можем записать эти выражения в общем виде:
\begin{equation}\label{eq:slau}\alpha_i' \odot \beta_1'b_{i1} \odot \beta_2'b_{i2} \odot ... \odot \beta_n'b_{in} = a_i(\beta_1'c_1 \odot \beta_2'c_2 \odot ... \odot \beta_n'c_n) ~ \forall i=\overline{1,n} \end{equation}
Или, если оставить $\alpha_i'$ на одной стороне, а $\beta_i'$ - на другой, получим:
\begin{equation}\label{eq:final_lin}\alpha_i' = \beta_1'b_{i1} \odot \beta_2'b_{i2} \odot ... \odot \beta_n'b_{in} \odot a_i(\beta_1'c_1 \odot \beta_2'c_2 \odot ... \odot \beta_n'c_n) ~ \forall i=\overline{1,n} \end{equation}
Заметим также, что $S$-блок будет линейно активным, как следует из (\ref{eq:slau}), тогда и только тогда, когда скалярное произведение $(\alpha', a)$ будет строго больше нуля.

И теперь при помощи (\ref{eq:final_lin}) можем записать алгоритм построения графа линейных переходов.

\begin{algorithm}[H]
\caption{Алгоритм построения графа линейный переходов}
\label{diff_graph_construct}
\textbf{Вход:} $XS_1$-схема $(a, B, c), n$ - размерность схемы.\\
\textbf{Выход:} Граф линейных переходов для схемы $(a, B, c)$.\\
Шаг 0. Создаем квадратную матрицу res размера $2^n$ и заполняем ее -1. \\
Шаг 1. Для каждого вектора $beta, \beta \in \{0, 1\}^n$ выполняем следующее: \\
Шаг 1.1. Находим все возможные $\alpha$, соответствующие этому $\beta$, подставляя $\beta$ в \ref{eq:final_lin}.\\
Шаг 1.2. Для каждого найденного вектора $\alpha$ делаем следующее:\\
Шаг 1.2.1. Вычисляем вес ребра $w$, исходящего из вершины $\alpha$, как $w = 0~ if~ (\alpha, a) = 0~ else~1$ \\
Шаг 1.2.2. Записываем в матрицу $res$ следующее: $res[\alpha][\beta] = w$.\\
Шаг 2. Возвращаем $res$.\\
\end{algorithm}

В ходе преддипломной практики был разработан формат представления графов и поддержан программно. Также был разработан и реализован алгоритм, конвертирующий $XS_1$ схему в граф линейных переходов. Соответствующий код можно найти в приложении к отчету. 

\newpage
\section*{4 Алгоритмы расчетов динамических характеристик графов переходов}
\addcontentsline{toc}{section}{4 Алгоритмы расчетов динамических характеристик графов переходов}

Для криптографической стойкости схемы важными характеристикиками являются следующие две величины [putnum]: минимальный вес пути заданной длины на графах линейных и разностных переходов, а также минимальноге отношение веса цикла к его длине на обоих графах.

Абстрагируемся от того, какой именно граф поступает нам на вход, линейных или разностных переходов, и просто обозначим его как $G$. Мы можем так поступить, поскольку свойства обоих графов очень схожи: оба графа являются ориентированными, у их ребер есть веса, причем вес может быть только 0 или 1, а также нет ребер, ведущих в вершину 000...0.

Для упрощения записи переименуем вершины графа $G$. В графах линейных и разностных переходов вершинами являются вектора из $\{0, 1\}^n$. Тогда пусть в $G$ вершин будут целыми числами, и тогда вершине $k$ из $G$ будет соответствовать на самом деле вершина $l$ из $\{0, 1\}^n$ такая, что $l$ - это битовая запись $k$.

\section{Минимальный вес пути заданной длины}

Будем полагать, что путь - это последовательность из вершин и ребер $v_1, e_1, v_2, e_2, ..., e_m$, где $e_i$ - это ребро, ведущее из $v_i$ в $v_{i+1}$. Тогда длина пути - это количество ребер в нем $m$, а вес - это сумма весов входящих в путь ребер. Также будем полагать, что ребра могут повторяться.

Обозначим как $V$ множество вершин графа $G$, $E$ - множество ребер графа $G$, $n$ - количество вершин в графе, $m$ - количество ребер в графе. Также пусть $(u, v) \in E$ - некоторое ребро, тогда его вес будем обозначать как $w(u, v)$.

Пусть нас интересует, какой минимальный вес пути длины $l$ на всем графе. Для этого будем искать пути минимального веса длины $l$ до каждой из вершин. Понятно, что вообще говоря кратчайший путь длины $l$ до любой из вершин может также и начинаться в любой вершине, поэтому сведем эту задачу к более известной: нахождение самого легкого пути длины $l$ до всех остальных вершин, причем путь всегда начинается из одной и той же вершины $v_{-1}$. Данная постановка задачи очень схожа с постановкой задачи в алгоритме Форда-Беллмана, в котором требуется найти легчайшие пути из заданной вершины до всех остальных (без учета длины). Вершина $v_{-1}$ является фиктивной, и будем полагать, что из $v_{-1}$ есть ребра до всех вершин из $V$, но нет ни одного ребра, ведущего в $v_{-1}$. Ребрам из $v_{-1}$ присвоим веса 0. В таком случае, нахождение легчайших путей длины $l$ до каждой из вершин в графе $G$ равнозначно нахождению легчайших путей длины $l+1$ из вершины $v_{-1}$ до всех остальных вершин.

 Рассмотрим алгоритм Беллмана-Форда и попытаемся модифицировать его согласно нашим нуждам.

\begin{algorithm}[H]
\caption{Алгоритм Беллмана-Форда}
\label{diff_graph_construct}
\textbf{Вход:} Граф $G$ и стартовая вершина $s$, от которой нужно найти вес легчайших путей до всех остальных вершин.\\
\textbf{Выход:} Массив $d$, в котором $d[v]$ содержит самый легкий путь из заданной вершины до вершины $v$.\\
Шаг 0. Создаем массив $d$ длины $n$ и заполняем его $+\infty$. \\
Шаг 1. Записываем $d[s] = 0$.\\
Шаг 2. Для $i$ от 1 до $n-1$ делаем следующее:\\
Шаг 2.1 Для всех ребер $(u, v) \in E:$\\
Шаг 2.1.1 Если $d[v] > d[u] + w(u,v)$, то $d[v] = d[u] + w(u,v)$\\
Шаг 3. Возвращаем $d$.\\
\end{algorithm}

Очевидно, сложность данного алгоритма $O(nm)$.

Видно, что основная проблема алгоритма Беллмана-Форда для нас заключается в том, что мы никак не фиксируем и не контролируем длину пути в ребрах. Теперь видоизменим алгоритм, и внешний цикл в нем сделаем не до $n$, а до $l$, где $l$ --- длина пути, чей минимальный вес мы ищем. Также на каждом шаге $k$ будем создавать новый массив $d_k$, в котором будут храниться минимальные веса длины $k$ до каждой из вершин. Запишем новый алгоритм:

\begin{algorithm}[H]
\caption{Модифицированный Алгоритм Беллмана-Форда}
\label{diff_graph_construct}
\textbf{Вход:} Граф $G$ и стартовая вершина $s$, от которой нужно найти вес легчайших путей до всех остальных вершин.\\
\textbf{Выход:} Массив $\pi_l$, в котором $\pi_l[v]$ содержит самый легкий путь длины $l$ до вершины $v$.\\
Шаг 0. Создаем массив $\pi_0$ длины $n$ и заполняем его $0$. \\
Шаг 1. Для $k$ от 1 до $l$ делаем следующее:\\
Шаг 1.1 Создаем массив $\pi_k$ и заполняем его $+\infty$,\\
Шаг 1.2 Для всех ребер $(u, v) \in E:$\\
Шаг 2.1.1 Если $\pi_k[v] > \pi_{k-1}[u] + w(u,v)$, то $\pi_k[v] = \pi_{k-1}[u] + w(u,v)$\\
Шаг 3. Возвращаем $\pi_l$.\\
\end{algorithm}

\begin{theorem}
Относительно модифицированного алгоритма Беллмана-Форда справедливо следующее:
1) Алгоритм решает задачу поиска кратчайших путей длины $l$ до каждой из вершин графа.
2) Алгоиртмическая сложность алгоритма: $O(nm)$.
\end{theorem}
\textbf{Доказательство}
Докажем каждое утверждение теоремы поотдельности.

1) Докажем данное утверждение методом индукции.

База индукции: на нулевом шаге в $\pi_0$ хранятся оптимальные веса.

Действительно, поскольку веса всех ребер неотрицательные, то и вес любого пути в графе обязательно $\ge$ 0. Следовательно, не может в графе существовать пути, вес которого меньше 0. Но на данном этапе в $\pi_0$ хранятся только нули, и следовательно, $\pi_0$ хранит минимальные по весу пути длины 0.

Индуктивный шаг: пусть на шагах $1, 2, ..., k-1$ были найдены минимальные по весу пути до каждой вершины длины $1, 2, ..., k-1$. Докажем, что и на $k$-том шаге будут найдены оптимальные пути. Положим от противного, это не так. Т.е. существует вершина $v'$, до которой существует путь длины $l: ~ v_1'e_1'v_2'e_2'v_3'...e_n'v_{n+1}'$, такой что $\sum_{i=1}^l w(e_i') < \pi_l[v']$ 


\section{Цикл минимального среднего веса}

В ходе исследования оказалось, что это известная задача в теории графов, обычно обозначаемая как mcm (minimum cycle mean).

\newpage
\section*{Список использованной литературы}
\addcontentsline{toc}{section}{Список использованной литературы}
\vspace*{1cm}

\begin{enumerate}
\item Ю.С. Харин, С.В. Агиевич, Д.В. Васильев, Г.В. Матвеев. Криптология.  Минск: БГУ,12-13, 511с, 2013.
\item В.Л. Цирлов. Основы информационной безопасности автоматизированных систем. Ростов-на-Дону: Феникс, 8-9, 253с, 2008.
\item Ж. Брассар. Современная криптология. Москва: Полимед, 19-21, 178с., 1999.
\item А.П. Алферов, А.Ю. Зубов, А.С. Кузьмин, А.В. Черемушкин. Основы криптографии. Москва: Гелиос АРВ, 59, 480с., 2002.
\item Б.Шнайер. Прикладная криптография. Москва: Диалектика,245-250 2003.
\end{enumerate}

\end{large}
\end{document}